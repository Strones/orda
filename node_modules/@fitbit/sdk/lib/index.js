"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const gulp_uglify_1 = tslib_1.__importDefault(require("gulp-uglify"));
const merge_stream_1 = tslib_1.__importDefault(require("merge-stream"));
const plugin_error_1 = tslib_1.__importDefault(require("plugin-error"));
const pumpify_1 = tslib_1.__importDefault(require("pumpify"));
const simple_random_1 = tslib_1.__importDefault(require("simple-random"));
const vinyl_fs_1 = tslib_1.__importDefault(require("vinyl-fs"));
const appPackageManifest_1 = tslib_1.__importDefault(require("./appPackageManifest"));
const buildTargets_1 = tslib_1.__importDefault(require("./buildTargets"));
const collectComponentSourceMaps_1 = tslib_1.__importDefault(require("./collectComponentSourceMaps"));
const compile_1 = tslib_1.__importDefault(require("./compile"));
const compileTranslations_1 = tslib_1.__importDefault(require("./compileTranslations"));
const componentManifest_1 = require("./componentManifest");
const componentTargets_1 = tslib_1.__importStar(require("./componentTargets"));
const convertImageToTXI_1 = tslib_1.__importDefault(require("./convertImageToTXI"));
const errataWorkarounds_1 = require("./errataWorkarounds");
const gulpMagicString_1 = tslib_1.__importDefault(require("./gulpMagicString"));
const diagnostics_1 = require("./diagnostics");
const externals_1 = tslib_1.__importDefault(require("./externals"));
const filterResourceTag_1 = tslib_1.__importDefault(require("./filterResourceTag"));
const findEntryPoint_1 = tslib_1.__importDefault(require("./findEntryPoint"));
const ProjectConfiguration_1 = require("./ProjectConfiguration");
const resources = tslib_1.__importStar(require("./resources"));
const validateIcon_1 = tslib_1.__importDefault(require("./validateIcon"));
const vinylAssertFiles_1 = tslib_1.__importDefault(require("./vinylAssertFiles"));
const zip_1 = tslib_1.__importDefault(require("./zip"));
function generateBuildId() {
    return `0x0${simple_random_1.default({ secure: true, chars: '0123456789abcdef', length: 15 })}`;
}
exports.generateBuildId = generateBuildId;
function loadProjectConfig({ onDiagnostic = diagnostics_1.logDiagnosticToConsole, fileName = 'package.json', }) {
    try {
        const config = ProjectConfiguration_1.normalizeProjectConfig(JSON.parse(fs_1.default.readFileSync(fileName, 'utf-8')));
        const diagnostics = ProjectConfiguration_1.validate(config);
        diagnostics.diagnostics.forEach(diagnostic => onDiagnostic(Object.assign({ file: { path: fileName } }, diagnostic)));
        if (diagnostics.fatalError)
            throw new Error('Project configuration is invalid');
        if (config.enableProposedAPI) {
            onDiagnostic({
                category: diagnostics_1.DiagnosticCategory.Warning,
                messageText: 'Targeting proposed API may cause your app to behave unexpectedly. Use only when needed for development or QA.',
            });
        }
        return config;
    }
    catch (err) {
        throw new plugin_error_1.default('projectConfig', err, { fileName });
    }
}
exports.loadProjectConfig = loadProjectConfig;
function buildComponent({ projectConfig, component, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const { inputs, output, notFoundIsFatal } = componentTargets_1.default[component];
    const entryPoint = findEntryPoint_1.default(inputs, { onDiagnostic, component, notFoundIsFatal });
    if (!entryPoint)
        return;
    return new pumpify_1.default.obj(compile_1.default(entryPoint, output, {
        onDiagnostic,
        external: externals_1.default[component],
        allowUnknownExternals: projectConfig.enableProposedAPI,
    }), gulp_uglify_1.default({
        mangle: {
            toplevel: true,
        },
        output: {
            semicolons: false,
        },
        compress: false,
    }));
}
exports.buildComponent = buildComponent;
function buildDeviceResources(projectConfig, { displayName, resourceFilterTag }, onDiagnostic = diagnostics_1.logDiagnosticToConsole) {
    onDiagnostic({
        messageText: `Building app for ${displayName}`,
        category: diagnostics_1.DiagnosticCategory.Message,
    });
    return new pumpify_1.default.obj(filterResourceTag_1.default(resourceFilterTag), validateIcon_1.default({ projectConfig, onDiagnostic }), convertImageToTXI_1.default(), vinylAssertFiles_1.default([resources.svgMain, resources.svgWidgets]));
}
exports.buildDeviceResources = buildDeviceResources;
function buildDeviceComponents({ projectConfig, buildId, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const baseJS = new pumpify_1.default.obj(buildComponent({
        projectConfig,
        onDiagnostic,
        component: componentTargets_1.ComponentType.DEVICE,
    }), gulpMagicString_1.default(errataWorkarounds_1.errataPrimaryExpressionInSwitch));
    return projectConfig.buildTargets.map((platform) => {
        const sourceMap = collectComponentSourceMaps_1.default();
        return new pumpify_1.default.obj(merge_stream_1.default(new pumpify_1.default.obj(baseJS, sourceMap.collector(componentTargets_1.ComponentType.DEVICE, platform)), new pumpify_1.default.obj(vinyl_fs_1.default.src('./resources/**', { base: '.' }), buildDeviceResources(projectConfig, buildTargets_1.default[platform], onDiagnostic)), new pumpify_1.default.obj(vinyl_fs_1.default.src('./i18n/**/*.po', { base: '.' }), compileTranslations_1.default())), componentManifest_1.makeDeviceManifest({ projectConfig, buildId }), zip_1.default(`device-${platform}.zip`, { compress: false }), sourceMap.emitter);
    });
}
exports.buildDeviceComponents = buildDeviceComponents;
function buildCompanion({ projectConfig, buildId, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const sourceMaps = collectComponentSourceMaps_1.default();
    const [companion, settings] = [componentTargets_1.ComponentType.COMPANION, componentTargets_1.ComponentType.SETTINGS]
        .map((componentType) => {
        let component = buildComponent({
            onDiagnostic,
            projectConfig,
            component: componentType,
        });
        if (component) {
            component = new pumpify_1.default.obj(component, sourceMaps.collector(componentType));
        }
        return component;
    });
    if (settings && !companion) {
        throw new Error('This project is being built with settings, but has no companion component');
    }
    const components = [companion, settings]
        .filter((component) => component !== undefined);
    if (components.length === 0)
        return;
    return new pumpify_1.default.obj(merge_stream_1.default(components), componentManifest_1.makeCompanionManifest({
        projectConfig,
        buildId,
        hasSettings: !!settings,
    }), zip_1.default('companion.zip'), sourceMaps.emitter);
}
exports.buildCompanion = buildCompanion;
function buildAppPackage({ projectConfig, buildId, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const components = buildDeviceComponents({ projectConfig, buildId, onDiagnostic });
    const companion = buildCompanion({ projectConfig, buildId, onDiagnostic });
    if (companion)
        components.push(companion);
    return new pumpify_1.default.obj(merge_stream_1.default(components), appPackageManifest_1.default({
        projectConfig,
        buildId,
        hasCompanion: !!companion,
    }), zip_1.default('app.fba'));
}
exports.buildAppPackage = buildAppPackage;
function build(onDiagnostic = diagnostics_1.logDiagnosticToConsole) {
    return new Promise((resolve, reject) => {
        const buildId = generateBuildId();
        const projectConfig = loadProjectConfig({ onDiagnostic });
        new pumpify_1.default.obj(buildAppPackage({ projectConfig, buildId, onDiagnostic }), vinyl_fs_1.default.dest('./build'))
            .on('error', reject)
            .on('finish', () => {
            onDiagnostic({
                messageText: `App UUID: ${projectConfig.appUUID}, BuildID: ${buildId}`,
                category: diagnostics_1.DiagnosticCategory.Message,
            });
            resolve();
        });
    }).catch((e) => {
        onDiagnostic({
            messageText: String(e),
            category: diagnostics_1.DiagnosticCategory.Error,
        });
        return Promise.reject();
    });
}
exports.build = build;
