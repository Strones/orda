"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const humanize_list_1 = tslib_1.__importDefault(require("humanize-list"));
const validator_1 = require("validator");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const DiagnosticList_1 = tslib_1.__importDefault(require("./DiagnosticList"));
var AppType;
(function (AppType) {
    AppType["APP"] = "app";
    AppType["CLOCKFACE"] = "clockface";
})(AppType = exports.AppType || (exports.AppType = {}));
exports.VALID_APP_TYPES = Object.values(AppType);
var BuildTarget;
(function (BuildTarget) {
    BuildTarget["HIGGS"] = "higgs";
    BuildTarget["MESON"] = "meson";
})(BuildTarget = exports.BuildTarget || (exports.BuildTarget = {}));
exports.MAX_DISPLAY_NAME_LENGTH = 30;
exports.LOCALES = Object.freeze({
    en: 'English',
    de: 'German',
    es: 'Spanish',
    fr: 'French',
    it: 'Italian',
    ja: 'Japanese',
    ko: 'Korean',
    nl: 'Dutch',
    sv: 'Swedish',
    'zh-cn': 'Chinese (S)',
    'zh-tw': 'Chinese (T)',
});
const permissionTypes = Object.freeze({
    access_activity: {
        name: 'Activity',
        description: 'Read user activities for today (distance, calories, steps, elevation and active minutes), and daily goals.',
    },
    access_user_profile: {
        name: 'User Profile',
        description: 'Read non-identifiable personal information (gender, age, height, weight, resting HR, basal metabolic rate, stride, HR zones).',
    },
    access_heart_rate: {
        name: 'Heart Rate',
        description: 'Application may read the heart-rate sensor in real-time.',
    },
    access_location: {
        name: 'Location',
        description: 'Application and companion may use GPS.',
    },
    access_internet: {
        name: 'Internet',
        description: 'Companion may communicate with the Internet using your phone data connection.',
    },
    run_background: {
        name: 'Run in background',
        description: 'Companion may run even when the application is not actively in use.',
    },
});
const restrictedPermissionTypes = Object.freeze({
    fitbit_token: {
        name: '[Restricted] Fitbit Token',
        description: 'Access Fitbit API token.',
    },
    external_app_communication: {
        name: '[Restricted] External Application Communication',
        description: 'Allows communication between external mobile applications and companion.',
    },
    access_secure_exchange: {
        name: '[Restricted] Secure Exchange',
        description: 'Allows securing any data and verifying that data was secured',
    },
});
const allPermissionTypes = Object.assign({}, permissionTypes, restrictedPermissionTypes);
function getPermissionTypes({ includeRestrictedPermissions = false }) {
    if (includeRestrictedPermissions)
        return allPermissionTypes;
    return permissionTypes;
}
exports.getPermissionTypes = getPermissionTypes;
function constrainedSetDiagnostics(actualValues, knownValues, valueTypeNoun) {
    const unknownValues = lodash_1.default.without(actualValues, ...knownValues);
    const diagnostics = new DiagnosticList_1.default();
    if (unknownValues.length > 0) {
        const unknownValueStrings = unknownValues.filter(lodash_1.default.isString);
        const unknownValueOther = lodash_1.default.without(unknownValues, ...unknownValueStrings).map(String);
        if (unknownValueStrings.length) {
            diagnostics.pushWarning(`One or more ${valueTypeNoun} was invalid: ${unknownValueStrings.join(', ')}`);
        }
        if (unknownValueOther.length) {
            diagnostics.pushFatalError(`One or more ${valueTypeNoun} was not a string: ${unknownValueOther.join(', ')}`);
        }
    }
    const duplicatedValues = lodash_1.default.uniq(actualValues)
        .filter(value => (actualValues.indexOf(value)
        !== actualValues.lastIndexOf(value)));
    if (duplicatedValues.length > 0) {
        diagnostics.pushWarning(`One or more ${valueTypeNoun} was specified multiple times: ${duplicatedValues.join(', ')}`);
    }
    return diagnostics;
}
function normalizeProjectConfig(config, defaults) {
    if (!lodash_1.default.isPlainObject(config)) {
        throw new TypeError('Project configuration root must be an object');
    }
    const mergedConfig = Object.assign({ appUUID: '', appType: AppType.APP, appDisplayName: '', iconFile: 'resources/icon.png', wipeColor: '', requestedPermissions: [], buildTargets: [], i18n: {} }, defaults, config.fitbit);
    const { requestedPermissions } = mergedConfig;
    if (!Array.isArray(requestedPermissions)) {
        throw new TypeError(`fitbit.requestedPermissions must be an array, not ${typeof requestedPermissions}`);
    }
    return mergedConfig;
}
exports.normalizeProjectConfig = normalizeProjectConfig;
function validateAppType(config) {
    const diagnostics = new DiagnosticList_1.default();
    if (exports.VALID_APP_TYPES.indexOf(config.appType) === -1) {
        const appTypeNames = humanize_list_1.default(exports.VALID_APP_TYPES, { conjunction: 'or' });
        diagnostics.pushFatalError(`App type '${config.appType}' is invalid, expected ${appTypeNames}`);
    }
    return diagnostics;
}
exports.validateAppType = validateAppType;
function validateDisplayName(name) {
    if (name.length === 0) {
        return 'Display name must not be blank';
    }
    if (name.length > exports.MAX_DISPLAY_NAME_LENGTH) {
        return `Display name must not exceed ${exports.MAX_DISPLAY_NAME_LENGTH} characters`;
    }
    return true;
}
exports.validateDisplayName = validateDisplayName;
function validateProjectDisplayName(config) {
    const diagnostics = new DiagnosticList_1.default();
    const result = validateDisplayName(config.appDisplayName);
    if (result !== true) {
        diagnostics.pushFatalError(result);
    }
    return diagnostics;
}
exports.validateProjectDisplayName = validateProjectDisplayName;
function validateWipeColor(config) {
    const diagnostics = new DiagnosticList_1.default();
    if (config.appType !== AppType.CLOCKFACE && !validator_1.isHexColor(config.wipeColor)) {
        diagnostics.pushFatalError('Wipe color must be a valid hex color');
    }
    return diagnostics;
}
exports.validateWipeColor = validateWipeColor;
function validateRequestedPermissions({ requestedPermissions }) {
    return constrainedSetDiagnostics(requestedPermissions, Object.keys(allPermissionTypes), 'requested permissions');
}
exports.validateRequestedPermissions = validateRequestedPermissions;
function validateBuildTarget({ buildTargets }) {
    const diagnostics = constrainedSetDiagnostics(buildTargets, Object.values(BuildTarget), 'build targets');
    if (buildTargets.length === 0) {
        diagnostics.pushFatalError('At least one build target must be enabled');
    }
    return diagnostics;
}
exports.validateBuildTarget = validateBuildTarget;
function validateLocaleDisplayName({ i18n }, localeKey) {
    const diagnostics = new DiagnosticList_1.default();
    const locale = i18n[localeKey];
    if (!locale)
        return diagnostics;
    if (!locale.name || locale.name.length === 0) {
        diagnostics.pushFatalError(`Localized display name for ${exports.LOCALES[localeKey]} must not be blank`);
    }
    if (locale.name.length > exports.MAX_DISPLAY_NAME_LENGTH) {
        diagnostics.pushFatalError(`Localized display name for ${exports.LOCALES[localeKey]} must not exceed ${exports.MAX_DISPLAY_NAME_LENGTH} characters`);
    }
    return diagnostics;
}
exports.validateLocaleDisplayName = validateLocaleDisplayName;
function validateLocaleDisplayNames(config) {
    const diagnostics = new DiagnosticList_1.default();
    for (const localeKey of Object.keys(exports.LOCALES)) {
        diagnostics.extend(validateLocaleDisplayName(config, localeKey));
    }
    return diagnostics;
}
exports.validateLocaleDisplayNames = validateLocaleDisplayNames;
function validateSupportedLocales({ i18n }) {
    const diagnostics = new DiagnosticList_1.default();
    const unknownLocales = lodash_1.default.without(Object.keys(i18n), ...Object.keys(exports.LOCALES));
    if (unknownLocales.length > 0) {
        diagnostics.pushWarning(`Invalid locales: ${unknownLocales.join(', ')}`);
    }
    return diagnostics;
}
exports.validateSupportedLocales = validateSupportedLocales;
function validateAppUUID({ appUUID }) {
    const diagnostics = new DiagnosticList_1.default();
    if (!validator_1.isUUID(String(appUUID))) {
        diagnostics.pushFatalError('appUUID must be a valid UUID, run "npx fitbit-build generate-appid" to fix');
    }
    return diagnostics;
}
exports.validateAppUUID = validateAppUUID;
function validate(config) {
    const diagnostics = new DiagnosticList_1.default();
    [
        validateAppUUID,
        validateProjectDisplayName,
        validateAppType,
        validateWipeColor,
        validateRequestedPermissions,
        validateBuildTarget,
        validateSupportedLocales,
        validateLocaleDisplayNames,
    ].forEach(validator => diagnostics.extend(validator(config)));
    return diagnostics;
}
exports.validate = validate;
