"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const stream_1 = require("stream");
const bison_i18n_1 = require("@fitbit/bison-i18n");
const plugin_error_1 = tslib_1.__importDefault(require("plugin-error"));
const PLUGIN_NAME = 'compileTranslations';
function compileTranslations() {
    const translations = new bison_i18n_1.TranslationLoader();
    const translationFiles = new Map();
    const transform = new stream_1.Transform({
        objectMode: true,
        transform(file, _, next) {
            if (file.isNull() || file.extname !== '.po') {
                return next(undefined, file);
            }
            const match = /^([a-z]{2})(-[a-z]{2})?\.po$/i.exec(file.basename);
            if (match === null) {
                next(new plugin_error_1.default(PLUGIN_NAME, `Translation file ${file.basename} has a bad name. Translation files must have names in the form ll-cc.po or ll.po (e.g. en-US.po)`, { fileName: file.relative }));
                return;
            }
            const [, language, region] = match;
            const normalizedTag = language.toLowerCase() + (region || '').toUpperCase();
            if (file.isBuffer()) {
                try {
                    const contents = file.contents.toString('utf-8');
                    translations.loadLanguage(normalizedTag, contents);
                    translationFiles.set(normalizedTag, file.clone({ contents: false }));
                    return next();
                }
                catch (error) {
                    next(new plugin_error_1.default(PLUGIN_NAME, error, { fileName: file.relative }));
                }
            }
            else {
                next(new plugin_error_1.default(PLUGIN_NAME, file.isStream() ? 'Streaming mode is not supported.' : 'Internal error processing file.', { fileName: file.relative }));
                return;
            }
        },
        flush(done) {
            const languageTable = translations.build();
            for (const language of languageTable.languages) {
                const file = translationFiles.get(language);
                try {
                    file.contents = Buffer.from(languageTable.getLanguage(language));
                    file.translationLanguage = language;
                }
                catch (error) {
                    done(new plugin_error_1.default(PLUGIN_NAME, error, { fileName: file.relative }));
                    return;
                }
                file.path = `l/${language}`;
                transform.push(file);
            }
            done();
        },
    });
    return transform;
}
exports.default = compileTranslations;
