import * as t from 'io-ts';
export declare const Primitive: t.UnionType<(t.NullType | t.StringType | t.NumberType | t.BooleanType)[], string | number | boolean | null, string | number | boolean | null, t.mixed>;
export declare type Primitive = t.TypeOf<typeof Primitive>;
export declare const Structured: t.UnionType<(t.AnyArrayType | t.DictionaryType<t.StringType, t.AnyType, {
    [x: string]: any;
}, {
    [x: string]: any;
}, t.mixed>)[], t.mixed[] | {
    [x: string]: any;
}, t.mixed[] | {
    [x: string]: any;
}, t.mixed>;
export declare type Structured = t.TypeOf<typeof Structured>;
export declare const Some: t.UnionType<(t.UnionType<(t.NullType | t.StringType | t.NumberType | t.BooleanType)[], string | number | boolean | null, string | number | boolean | null, t.mixed> | t.UnionType<(t.AnyArrayType | t.DictionaryType<t.StringType, t.AnyType, {
    [x: string]: any;
}, {
    [x: string]: any;
}, t.mixed>)[], t.mixed[] | {
    [x: string]: any;
}, t.mixed[] | {
    [x: string]: any;
}, t.mixed>)[], string | number | boolean | t.mixed[] | {
    [x: string]: any;
} | null, string | number | boolean | t.mixed[] | {
    [x: string]: any;
} | null, t.mixed>;
export declare type Some = t.TypeOf<typeof Some>;
export declare const RPCID: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, t.mixed>)[], string | number, string | number, t.mixed>;
export declare type RPCID = t.TypeOf<typeof RPCID>;
export declare const RPCParams: t.UnionType<(t.AnyArrayType | t.DictionaryType<t.StringType, t.AnyType, {
    [x: string]: any;
}, {
    [x: string]: any;
}, t.mixed>)[], t.mixed[] | {
    [x: string]: any;
}, t.mixed[] | {
    [x: string]: any;
}, t.mixed>;
export declare type RPCParams = t.TypeOf<typeof RPCParams>;
export declare const RPCError: t.IntersectionType<[t.InterfaceType<{
        code: t.RefinementType<t.NumberType, number, number, t.mixed>;
        message: t.StringType;
    }, {
        code: number;
        message: string;
    }, {
        code: number;
        message: string;
    }, t.mixed>, t.PartialType<{
        data: t.UnionType<(t.UnionType<(t.NullType | t.StringType | t.NumberType | t.BooleanType)[], string | number | boolean | null, string | number | boolean | null, t.mixed> | t.UnionType<(t.AnyArrayType | t.DictionaryType<t.StringType, t.AnyType, {
            [x: string]: any;
        }, {
            [x: string]: any;
        }, t.mixed>)[], t.mixed[] | {
            [x: string]: any;
        }, t.mixed[] | {
            [x: string]: any;
        }, t.mixed>)[], string | number | boolean | t.mixed[] | {
            [x: string]: any;
        } | null, string | number | boolean | t.mixed[] | {
            [x: string]: any;
        } | null, t.mixed>;
    }, {
        data?: string | number | boolean | t.mixed[] | {
            [x: string]: any;
        } | null | undefined;
    }, {
        data?: string | number | boolean | t.mixed[] | {
            [x: string]: any;
        } | null | undefined;
    }, t.mixed>], {
    code: number;
    message: string;
} & {
    data?: string | number | boolean | t.mixed[] | {
        [x: string]: any;
    } | null | undefined;
}, {
    code: number;
    message: string;
} & {
    data?: string | number | boolean | t.mixed[] | {
        [x: string]: any;
    } | null | undefined;
}, t.mixed>;
export declare type RPCError = t.TypeOf<typeof RPCError>;
export declare const RequestJSON: t.IntersectionType<[t.InterfaceType<{
        jsonrpc: t.LiteralType<"2.0">;
        method: t.StringType;
        id: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, t.mixed>)[], string | number, string | number, t.mixed>;
        params: t.UnionType<(t.UndefinedType | t.UnionType<(t.AnyArrayType | t.DictionaryType<t.StringType, t.AnyType, {
            [x: string]: any;
        }, {
            [x: string]: any;
        }, t.mixed>)[], t.mixed[] | {
            [x: string]: any;
        }, t.mixed[] | {
            [x: string]: any;
        }, t.mixed>)[], t.mixed[] | {
            [x: string]: any;
        } | undefined, t.mixed[] | {
            [x: string]: any;
        } | undefined, t.mixed>;
    }, {
        jsonrpc: "2.0";
        method: string;
        id: string | number;
        params: t.mixed[] | {
            [x: string]: any;
        } | undefined;
    }, {
        jsonrpc: "2.0";
        method: string;
        id: string | number;
        params: t.mixed[] | {
            [x: string]: any;
        } | undefined;
    }, t.mixed>, t.PartialType<{
        result: t.UndefinedType;
        error: t.UndefinedType;
    }, {
        result?: undefined;
        error?: undefined;
    }, {
        result?: undefined;
        error?: undefined;
    }, t.mixed>], {
    jsonrpc: "2.0";
    method: string;
    id: string | number;
    params: t.mixed[] | {
        [x: string]: any;
    } | undefined;
} & {
    result?: undefined;
    error?: undefined;
}, {
    jsonrpc: "2.0";
    method: string;
    id: string | number;
    params: t.mixed[] | {
        [x: string]: any;
    } | undefined;
} & {
    result?: undefined;
    error?: undefined;
}, t.mixed>;
export declare type RequestJSON = t.TypeOf<typeof RequestJSON>;
export declare const NotificationJSON: t.IntersectionType<[t.InterfaceType<{
        jsonrpc: t.LiteralType<"2.0">;
        method: t.StringType;
        params: t.UnionType<(t.UndefinedType | t.UnionType<(t.AnyArrayType | t.DictionaryType<t.StringType, t.AnyType, {
            [x: string]: any;
        }, {
            [x: string]: any;
        }, t.mixed>)[], t.mixed[] | {
            [x: string]: any;
        }, t.mixed[] | {
            [x: string]: any;
        }, t.mixed>)[], t.mixed[] | {
            [x: string]: any;
        } | undefined, t.mixed[] | {
            [x: string]: any;
        } | undefined, t.mixed>;
    }, {
        jsonrpc: "2.0";
        method: string;
        params: t.mixed[] | {
            [x: string]: any;
        } | undefined;
    }, {
        jsonrpc: "2.0";
        method: string;
        params: t.mixed[] | {
            [x: string]: any;
        } | undefined;
    }, t.mixed>, t.PartialType<{
        id: t.UndefinedType;
        result: t.UndefinedType;
        error: t.UndefinedType;
    }, {
        id?: undefined;
        result?: undefined;
        error?: undefined;
    }, {
        id?: undefined;
        result?: undefined;
        error?: undefined;
    }, t.mixed>], {
    jsonrpc: "2.0";
    method: string;
    params: t.mixed[] | {
        [x: string]: any;
    } | undefined;
} & {
    id?: undefined;
    result?: undefined;
    error?: undefined;
}, {
    jsonrpc: "2.0";
    method: string;
    params: t.mixed[] | {
        [x: string]: any;
    } | undefined;
} & {
    id?: undefined;
    result?: undefined;
    error?: undefined;
}, t.mixed>;
export declare type NotificationJSON = t.TypeOf<typeof NotificationJSON>;
export declare const ResponseJSON: t.IntersectionType<[t.InterfaceType<{
        jsonrpc: t.LiteralType<"2.0">;
        result: t.UnionType<(t.UnionType<(t.NullType | t.StringType | t.NumberType | t.BooleanType)[], string | number | boolean | null, string | number | boolean | null, t.mixed> | t.UnionType<(t.AnyArrayType | t.DictionaryType<t.StringType, t.AnyType, {
            [x: string]: any;
        }, {
            [x: string]: any;
        }, t.mixed>)[], t.mixed[] | {
            [x: string]: any;
        }, t.mixed[] | {
            [x: string]: any;
        }, t.mixed>)[], string | number | boolean | t.mixed[] | {
            [x: string]: any;
        } | null, string | number | boolean | t.mixed[] | {
            [x: string]: any;
        } | null, t.mixed>;
        id: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, t.mixed>)[], string | number, string | number, t.mixed>;
    }, {
        jsonrpc: "2.0";
        result: string | number | boolean | t.mixed[] | {
            [x: string]: any;
        } | null;
        id: string | number;
    }, {
        jsonrpc: "2.0";
        result: string | number | boolean | t.mixed[] | {
            [x: string]: any;
        } | null;
        id: string | number;
    }, t.mixed>, t.PartialType<{
        method: t.UndefinedType;
        params: t.UndefinedType;
        error: t.UndefinedType;
    }, {
        method?: undefined;
        params?: undefined;
        error?: undefined;
    }, {
        method?: undefined;
        params?: undefined;
        error?: undefined;
    }, t.mixed>], {
    jsonrpc: "2.0";
    result: string | number | boolean | t.mixed[] | {
        [x: string]: any;
    } | null;
    id: string | number;
} & {
    method?: undefined;
    params?: undefined;
    error?: undefined;
}, {
    jsonrpc: "2.0";
    result: string | number | boolean | t.mixed[] | {
        [x: string]: any;
    } | null;
    id: string | number;
} & {
    method?: undefined;
    params?: undefined;
    error?: undefined;
}, t.mixed>;
export declare type ResponseJSON = t.TypeOf<typeof ResponseJSON>;
export declare const ErrorJSON: t.IntersectionType<[t.InterfaceType<{
        jsonrpc: t.LiteralType<"2.0">;
        error: t.IntersectionType<[t.InterfaceType<{
                code: t.RefinementType<t.NumberType, number, number, t.mixed>;
                message: t.StringType;
            }, {
                code: number;
                message: string;
            }, {
                code: number;
                message: string;
            }, t.mixed>, t.PartialType<{
                data: t.UnionType<(t.UnionType<(t.NullType | t.StringType | t.NumberType | t.BooleanType)[], string | number | boolean | null, string | number | boolean | null, t.mixed> | t.UnionType<(t.AnyArrayType | t.DictionaryType<t.StringType, t.AnyType, {
                    [x: string]: any;
                }, {
                    [x: string]: any;
                }, t.mixed>)[], t.mixed[] | {
                    [x: string]: any;
                }, t.mixed[] | {
                    [x: string]: any;
                }, t.mixed>)[], string | number | boolean | t.mixed[] | {
                    [x: string]: any;
                } | null, string | number | boolean | t.mixed[] | {
                    [x: string]: any;
                } | null, t.mixed>;
            }, {
                data?: string | number | boolean | t.mixed[] | {
                    [x: string]: any;
                } | null | undefined;
            }, {
                data?: string | number | boolean | t.mixed[] | {
                    [x: string]: any;
                } | null | undefined;
            }, t.mixed>], {
            code: number;
            message: string;
        } & {
            data?: string | number | boolean | t.mixed[] | {
                [x: string]: any;
            } | null | undefined;
        }, {
            code: number;
            message: string;
        } & {
            data?: string | number | boolean | t.mixed[] | {
                [x: string]: any;
            } | null | undefined;
        }, t.mixed>;
        id: t.UnionType<(t.NullType | t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, t.mixed>)[], string | number, string | number, t.mixed>)[], string | number | null, string | number | null, t.mixed>;
    }, {
        jsonrpc: "2.0";
        error: any & {
            data?: string | number | boolean | t.mixed[] | {
                [x: string]: any;
            } | null | undefined;
        };
        id: string | number | null;
    }, {
        jsonrpc: "2.0";
        error: any & {
            data?: string | number | boolean | t.mixed[] | {
                [x: string]: any;
            } | null | undefined;
        };
        id: string | number | null;
    }, t.mixed>, t.PartialType<{
        method: t.UndefinedType;
        params: t.UndefinedType;
        result: t.UndefinedType;
    }, {
        method?: undefined;
        params?: undefined;
        result?: undefined;
    }, {
        method?: undefined;
        params?: undefined;
        result?: undefined;
    }, t.mixed>], {
    jsonrpc: "2.0";
    error: any & {
        data?: string | number | boolean | t.mixed[] | {
            [x: string]: any;
        } | null | undefined;
    };
    id: string | number | null;
} & {
    method?: undefined;
    params?: undefined;
    result?: undefined;
}, {
    jsonrpc: "2.0";
    error: any & {
        data?: string | number | boolean | t.mixed[] | {
            [x: string]: any;
        } | null | undefined;
    };
    id: string | number | null;
} & {
    method?: undefined;
    params?: undefined;
    result?: undefined;
}, t.mixed>;
export declare type ErrorJSON = t.TypeOf<typeof ErrorJSON>;
export interface Request {
    kind: 'request';
    method: string;
    params?: Structured;
    id: RPCID;
}
export interface Notification {
    kind: 'notification';
    method: string;
    params?: Structured;
}
export interface Response {
    kind: 'response';
    result: Some;
    id: RPCID;
}
export interface Error {
    kind: 'error';
    error: {
        code: number;
        message: string;
        data?: Some;
    };
    id: RPCID | null;
}
export declare type Message = Request | Notification | Response | Error;
export declare function parse(obj: object): Message;
export declare function request(id: RPCID, method: string, params?: RPCParams): RequestJSON;
export declare function notification(method: string, params?: RPCParams): NotificationJSON;
export declare function response(id: RPCID, result?: Some): ResponseJSON;
export interface ErrorObject extends RPCError {
    id?: RPCID | null;
}
export declare function error(error: ErrorObject): ErrorJSON;
