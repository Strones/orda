"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fdb_host_1 = require("@fitbit/fdb-host");
const jszip_1 = tslib_1.__importDefault(require("jszip"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const ws_1 = tslib_1.__importDefault(require("ws"));
const websocket_stream_1 = tslib_1.__importDefault(require("websocket-stream"));
const auth = tslib_1.__importStar(require("../auth"));
const environment_1 = tslib_1.__importDefault(require("../auth/environment"));
async function getBundleInfo(bundleData) {
    const bundleZip = await jszip_1.default.loadAsync(bundleData);
    const manifestStr = await bundleZip.file('manifest.json').async('text');
    const manifest = JSON.parse(manifestStr);
    return {
        uuid: manifest.uuid,
        buildID: manifest.buildId.slice(2),
    };
}
function makeHostCapabilities(hostType, hostProperties) {
    const { maxAPIVersion } = hostProperties;
    const capabilities = {
        app: {
            appBundle: true,
            appCompatibility: [
                {
                    maxAPIVersion,
                    family: 'Higgs',
                    version: '277.255.1.999',
                },
            ],
        },
        companion: Object.assign({ companionBundle: true }, (maxAPIVersion && { companionCompatibility: { maxAPIVersion } })),
    };
    return capabilities[hostType];
}
function makeHostInfo(hostType) {
    return {
        device: `Mock ${lodash_1.default.startCase(hostType)} Host`,
        hostKind: {
            app: 'device',
            companion: 'companion',
        }[hostType],
    };
}
function eventPromise(socket, eventName) {
    return new Promise(resolve => socket.once(eventName, resolve));
}
async function createHostConnection(hostType) {
    const authToken = await auth.getAccessToken();
    return new ws_1.default(environment_1.default().config.devRelayUrl, {
        headers: {
            Authorization: `Bearer ${authToken}`,
            'X-Relay-Host-Roles': `${hostType.toUpperCase()}_HOST`,
            'X-Relay-Host-ID': `mock_${hostType}`,
            'X-Relay-Host-Display-Name': `Mock ${lodash_1.default.startCase(hostType)} Host`,
        },
    });
}
exports.createHostConnection = createHostConnection;
async function createDebuggerHost(socket, hostType, handleLog, hostProperties) {
    const initMessageBuffer = await eventPromise(socket, 'message');
    const initMessage = JSON.parse(initMessageBuffer.toString());
    handleLog('Debugger connected');
    const host = fdb_host_1.Host.create(websocket_stream_1.default(socket, {
        binary: false,
        objectMode: true,
    }), Object.assign({ maxMessageSize: initMessage.maxMessageSize }, makeHostInfo(hostType)));
    host.setInstallHandler(async (bundleData) => {
        const bundleInfo = await getBundleInfo(bundleData);
        handleLog(`Sideload received with appID:${bundleInfo.uuid} buildID:${bundleInfo.buildID}`);
        return {
            app: bundleInfo,
            components: [hostType],
        };
    }, makeHostCapabilities(hostType, hostProperties));
    await eventPromise(socket, 'close');
    handleLog('Debugger or relay closed connection');
}
exports.createDebuggerHost = createDebuggerHost;
