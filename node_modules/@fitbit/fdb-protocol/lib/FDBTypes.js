"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var t = require("io-ts");
var isUUID = require("validator/lib/isUUID");
var semver = require("semver");
var ErrorCodes;
(function (ErrorCodes) {
    ErrorCodes[ErrorCodes["HostNotInitialized"] = -32001] = "HostNotInitialized";
    ErrorCodes[ErrorCodes["MessageTooLong"] = -32002] = "MessageTooLong";
    ErrorCodes[ErrorCodes["ResponseTooLong"] = -32003] = "ResponseTooLong";
    ErrorCodes[ErrorCodes["RequestError"] = -1] = "RequestError";
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
exports.NonNegativeInteger = t.refinement(t.Integer, function (v) { return v >= 0; }, 'NonNegativeInteger');
exports.PositiveInteger = t.refinement(t.Integer, function (v) { return v > 0; }, 'PositiveInteger');
exports.ObjectURI = t.string;
exports.AppFileURI = t.refinement(exports.ObjectURI, function (s) { return s.startsWith('app:///'); }, 'AppFileURI');
exports.Timestamp = t.number;
exports.Semver = new t.Type('Semver', function (value) { return t.string.is(value) && semver.valid(value) !== null; }, function (value, context) { return t.string.validate(value, context).chain(function (str) {
    var version = semver.valid(str);
    return version === null ? t.failure(str, context) : t.success(version);
}); }, t.identity);
exports.ReleaseSemver = t.refinement(exports.Semver, function (s) { return semver.parse(s).prerelease.length === 0; }, 'ReleaseSemver');
exports.Position = t.intersection([
    t.interface({
        source: exports.AppFileURI,
        line: exports.NonNegativeInteger,
        column: exports.NonNegativeInteger,
    }),
    t.partial({
        generated: t.boolean,
        name: t.string,
    }),
], 'Position');
exports.UUID = t.refinement(t.string, function (s) { return isUUID(s); }, 'UUID');
exports.BuildID = t.refinement(t.string, function (s) { return /^[0-9a-fA-F]{16}$/.test(s); }, 'BuildID');
exports.App = t.interface({
    uuid: exports.UUID,
    buildID: exports.BuildID,
}, 'App');
exports.Component = t.union([t.literal('app'), t.literal('companion'), t.literal('settings')], 'Component');
exports.AppComponent = t.intersection([exports.App, t.interface({ component: exports.Component })], 'AppComponent');
exports.DeviceHost = t.partial({
    hostID: t.string,
}, 'DeviceHost');
exports.InstalledApp = t.union([exports.App, exports.DeviceHost], 'InstalledApp');
exports.InstalledAppComponent = t.union([exports.AppComponent, exports.DeviceHost], 'InstalledAppComponent');
exports.ProtocolCapabilities = t.partial({
    batchRequest: t.boolean,
    maxMessageSize: exports.PositiveInteger,
}, 'ProtocolCapabilities');
exports.IOCapabilities = t.partial({
    write: t.boolean,
    additionalEncodings: t.array(t.string),
}, 'IOCapabilities');
exports.ConsoleDebuggerCapabilities = t.partial({
    appLogging: t.boolean,
}, 'ConsoleDebuggerCapabilities');
exports.DebuggerCapabilities = t.partial({
    protocol: exports.ProtocolCapabilities,
    io: exports.IOCapabilities,
    console: exports.ConsoleDebuggerCapabilities,
    experimental: t.any,
}, 'DebuggerCapabilities');
exports.InitializeParams = t.intersection([
    t.interface({
        capabilities: exports.DebuggerCapabilities,
    }),
    t.partial({
        userAgent: t.string,
    }),
], 'InitializeParams');
exports.APICompatibilityDescriptor = t.intersection([
    t.interface({
        maxAPIVersion: exports.ReleaseSemver,
    }),
    t.partial({
        exactAPIVersion: t.array(exports.Semver),
    }),
], 'APICompatibilityDescriptor');
exports.AppHostDescriptor = t.intersection([
    t.partial({
        maxAPIVersion: exports.ReleaseSemver,
        exactAPIVersion: t.array(exports.Semver),
    }),
    t.interface({
        family: t.string,
        version: t.string,
    }),
], 'AppHostDescriptor');
exports.CompanionHostDescriptor = exports.APICompatibilityDescriptor;
exports.ApplicationHostCapabilities = t.partial({
    install: t.partial({
        sideloadStream: t.boolean,
        appBundle: t.boolean,
        companionBundle: t.boolean,
        appCompatibility: t.array(exports.AppHostDescriptor),
        companionCompatibility: exports.CompanionHostDescriptor,
    }),
    launch: t.partial({
        appComponent: t.partial({
            canLaunch: t.boolean,
        }),
    }),
    screenshot: t.intersection([
        t.partial({
            stream: t.boolean,
        }),
        t.interface({
            imageFormats: t.array(t.string),
        }),
    ]),
}, 'ApplicationHostCapabilities');
exports.HostCapabilities = t.partial({
    protocol: exports.ProtocolCapabilities,
    io: exports.IOCapabilities,
    appHost: exports.ApplicationHostCapabilities,
    experimental: t.any,
}, 'HostCapabilities');
exports.HostKind = t.union([
    t.literal('device'),
    t.literal('companion'),
]);
exports.InitializeResult = t.intersection([
    t.interface({
        device: t.string,
        hostKind: exports.HostKind,
        capabilities: exports.HostCapabilities,
    }),
    t.partial({
        hostID: t.string,
    }),
], 'InitializeResult');
exports.ConsoleMessageKind = t.union([
    t.literal('log'),
    t.literal('info'),
    t.literal('warn'),
    t.literal('error'),
]);
exports.ConsoleMessage = t.intersection([
    t.partial({
        timestamp: exports.Timestamp,
        position: exports.Position,
        fromHost: t.boolean,
    }),
    t.interface({
        emittedBy: exports.InstalledAppComponent,
        kind: exports.ConsoleMessageKind,
        message: t.array(t.any),
    }),
], 'ConsoleMessage');
exports.TraceMessageKind = t.union([
    t.literal('trace'),
    t.literal('assert'),
    t.literal('exception'),
]);
exports.TraceMessage = t.intersection([
    t.interface({
        emittedBy: exports.InstalledAppComponent,
        stack: t.array(exports.Position),
        kind: exports.TraceMessageKind,
        message: t.array(t.any),
    }),
    t.partial({
        timestamp: exports.Timestamp,
    }),
], 'TraceMessage');
exports.StreamToken = t.union([t.Integer, t.string], 'StreamToken');
exports.StreamOpenResponse = t.interface({
    stream: exports.StreamToken,
}, 'StreamOpenResponse');
exports.StreamCloseParams = t.interface({
    stream: exports.StreamToken,
}, 'StreamCloseParams');
exports.IOWriteParams = t.intersection([
    t.interface({
        stream: exports.StreamToken,
        data: t.string,
    }),
    t.partial({
        encoding: t.string,
    }),
], 'IOWriteParams');
exports.ComponentBundleKind = t.union([
    t.literal('app'),
    t.literal('companion'),
]);
exports.AppInstallStreamBeginParams = t.interface({
    componentBundle: exports.ComponentBundleKind,
}, 'AppInstallStreamBeginParams');
exports.AppInstallResult = t.interface({
    app: exports.App,
    components: t.array(exports.Component),
}, 'AppInstallResult');
exports.LaunchComponentParams = t.interface({
    uuid: exports.UUID,
    component: exports.Component,
}, 'LaunchComponentParams');
exports.AppScreenshotStreamCaptureParams = t.interface({
    stream: exports.StreamToken,
    imageFormat: t.string,
}, 'AppScreenshotStreamCaptureParams');
exports.AppScreenshotStreamCaptureResult = t.partial({
    length: exports.NonNegativeInteger,
}, 'AppScreenshotStreamCaptureResult');
exports.AppDebugEvalParams = t.interface({
    cmd: t.string,
}, 'AppDebugEvalParams');
exports.AppDebugEvalValueResult = t.interface({
    success: t.literal(true),
    value: t.string,
}, 'AppDebugEvalValueResult');
exports.AppDebugEvalFailureResult = t.interface({
    success: t.literal(false),
}, 'AppDebugEvalFailureResult');
exports.AppDebugEvalResult = t.union([
    exports.AppDebugEvalValueResult,
    exports.AppDebugEvalFailureResult,
], 'AppDebugEvalResult');
